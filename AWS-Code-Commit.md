### AWS CodeCommit

Provides the ability to host highly **scalable private Git repositories** and collaborate on code.  

* Removes the need to host, maintain, back up, or scale source control servers
* Customize user-specific access to repositories with automatically encrypted files in transit
* Keep repositories highly available and accessible with scalable, redundant, and durable architecture
* Maintain your repositories close to build, staging, and production environments on AWS

![image](https://user-images.githubusercontent.com/114364831/211430777-b10f4cc8-a8de-4f7d-bde5-41b20254ef89.png)

Cases in which CodeCommit is not the correct solution:

### First Incorrect Use Case

**Use case:**

* Large files that change frequently

**Description:**

* Git uses **delta encoding** to store differences between versions of files. For example, if you change a few words in a document, Git will only store those changed words. If you have files or objects over 5 MB with many changes, Git might need to reconstruct a large chain of delta differences. This can consume an increasing amount of compute resources on both your local computer and in CodeCommit as these files grow over time.

**Solution:**

* To version large files, consider Amazon Simple Storage Service (Amazon S3)

### Second Incorrect Use Case

**Use case:**

* Database

**Description:**

* Git repositories grow larger over time. Because versioning tracks all changes, any change will increase your repository size. In other words, as you commit data, even if you delete data in a commit, data is added to a repository. As there is more data to process and transmit over time, Git will slow down. This is particularly detrimental to a database use case. Git was not designed as a database.

**Solution:**

* To create and use a database with consistent performance regardless of size, consider Amazon DynamoDB.

### Third Incorrect Use Case

**Use case:**

* Audit trails

**Description:**

* Typically, audit trails are kept for long periods of time and are continuously generated by system processes at a very frequent cadence. Git was designed to securely store source code generated by groups of developers on a development cycle. Rapidly changing repositories that continually store programmatically-generated system changes will see performance degrade over time.

**Solution:**

* To store audit trails, consider Amazon Simple Storage Service (Amazon S3). To audit AWS activity, depending on your use case, consider using AWS CloudTrail, AWS Config, or Amazon CloudWatch.

### Fourth Incorrect Use Case

**Use case:**

* Backups

**Description:**

* Git was designed to version source code written by developers. You can push commits to two remote repositories, including a CodeCommit repository, as a backup strategy. However, Git was not designed to handle backups of your computer file system, database dumps, or similar backup content. Doing so might slow down your system and increase the amount of time required to clone and push a repository.

**Solution:**

* Back up all data types with AWS. Our storage services for object (Amazon S3 and Amazon S3 Glacier), file (Amazon Elastic File System), and block (Amazon Elastic Block Storage) support industry-leading scalability, availability, durability, and security so your backups are protected and available when needed.

### Five Incorrect Use Case

**Use case:**

* Large numbers of branches or references

**Description:**

* When a Git client pushes or pulls repository data, the remote server must send all branches and references such as tags, even if you are only interested in a single branch. If you have thousands of branches and references, this can take time to process and send (pack negotiation) and result in apparently slow repository response. The more branches and tags you have, the longer this process can take. We recommend using CodeCommit, but delete branches and tags that are no longer needed.

**Solution:**

* To analyze the number of references in a CodeCommit repository to determine which might not be needed, you can use one of the following commands:
    * Linux, macOS, or Unix, or Bash emulator on Windows:
        * `git ls-remote | wc -l`
            * The command `git ls-remote` is used to show references in a remote repository, and the output of that command is piped to the command `wc -l`, which counts the number of lines in the output. So the command will show the number of references (such as branches or tags) in a remote repository.
    * Powershell:
        * `git ls-remote | Measure-Object -line`
            * The command `git ls-remote` lists references in a remote repository, while `Measure-Object -line` is a PowerShell command that counts the number of lines in the output of the previous command. Together, this command would list the references in a remote repository and display the number of lines in the output.
