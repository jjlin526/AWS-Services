### AWS CodeCommit

Provides the ability to host highly **scalable private Git repositories** and collaborate on code.  

* Removes the need to host, maintain, back up, or scale source control servers
* Customize user-specific access to repositories with automatically encrypted files in transit
* Keep repositories highly available and accessible with scalable, redundant, and durable architecture
* Maintain your repositories close to build, staging, and production environments on AWS

![image](https://user-images.githubusercontent.com/114364831/211430777-b10f4cc8-a8de-4f7d-bde5-41b20254ef89.png)

Cases in which CodeCommit is not the correct solution:

### First Incorrect Use Case

**Use case:**

* Large files that change frequently

**Description:**

* Git uses **delta encoding** to store differences between versions of files. For example, if you change a few words in a document, Git will only store those changed words. If you have files or objects over 5 MB with many changes, Git might need to reconstruct a large chain of delta differences. This can consume an increasing amount of compute resources on both your local computer and in CodeCommit as these files grow over time.

**Solution:**

* To version large files, consider Amazon Simple Storage Service (Amazon S3)

### Second Incorrect Use Case

**Use case:**

* Database

**Description:**

* Git repositories grow larger over time. Because versioning tracks all changes, any change will increase your repository size. In other words, as you commit data, even if you delete data in a commit, data is added to a repository. As there is more data to process and transmit over time, Git will slow down. This is particularly detrimental to a database use case. Git was not designed as a database.

**Solution:**

* To create and use a database with consistent performance regardless of size, consider Amazon DynamoDB.

### Third Incorrect Use Case

**Use case:**

* Audit trails

**Description:**

* Typically, audit trails are kept for long periods of time and are continuously generated by system processes at a very frequent cadence. Git was designed to securely store source code generated by groups of developers on a development cycle. Rapidly changing repositories that continually store programmatically-generated system changes will see performance degrade over time.

**Solution:**

* To store audit trails, consider Amazon Simple Storage Service (Amazon S3). To audit AWS activity, depending on your use case, consider using AWS CloudTrail, AWS Config, or Amazon CloudWatch.

### Fourth Incorrect Use Case

**Use case:**

* Backups

**Description:**

* Git was designed to version source code written by developers. You can push commits to two remote repositories, including a CodeCommit repository, as a backup strategy. However, Git was not designed to handle backups of your computer file system, database dumps, or similar backup content. Doing so might slow down your system and increase the amount of time required to clone and push a repository.

**Solution:**

* Back up all data types with AWS. Our storage services for object (Amazon S3 and Amazon S3 Glacier), file (Amazon Elastic File System), and block (Amazon Elastic Block Storage) support industry-leading scalability, availability, durability, and security so your backups are protected and available when needed.
